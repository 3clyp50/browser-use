---
title: "Action Parameters"
description: "Define parameters for custom actions using function arguments or Pydantic models"
icon: "gear"
mode: "wide"
---

Browser Use supports two patterns for defining action parameters: normal function arguments, or a Pydantic model.

## Function Arguments

For simple actions that don't need default values, you can define the action parameters directly as arguments to the function. This one takes a single string argument, `css_selector`.
When the LLM calls an action, it sees its argument names & types, and will provide values that fit.

```python
@controller.action('Click element')
async def click_element(css_selector: str, browser_session: Browser) -> ActionResult:
    # css_selector is an action param the LLM must provide when calling
    # browser_session is a special framework-provided param to access the browser APIs (see below)
    
    # Get the current CDP session to interact with the browser
    cdp_session = await browser_session.get_or_create_cdp_session()
    
    # Use CDP to evaluate JavaScript and click the element
    await cdp_session.cdp_client.send.Runtime.evaluate(
        params={'expression': f'document.querySelector("{css_selector}").click()'},
        session_id=cdp_session.session_id,
    )
    return ActionResult(extracted_content=f"Clicked element {css_selector}")
```

## Pydantic Model

You can define a pydantic model for the parameters your action expects by setting a `@controller.action(..., param_model=MyParams)`.
This allows you to use optional parameters, default values, `Annotated[...]` types with custom validation, field descriptions, and other features offered by pydantic.

When the agent calls calls your agent function, an instance of your model with the values filled by the LLM will be passed as the argument named `params` to your action function.

Using a pydantic model is helpful because it allows more flexibility and power to enforce the schema of the values the LLM should provide.
The LLM gets the entire pydantic JSON schema for your `param_model`, it will see the function name & description + individual field names, types, descriptions, and default values.

```python
from typing import Annotated
from pydantic import BaseModel, AfterValidator, Field
from browser_use import ActionResult

class MyParams(BaseModel):
    field1: int
    field2: str = 'default value'
    field3: Annotated[str, AfterValidator(lambda s: s.lower())]  # example: enforce always lowercase
    field4: str = Field(default='abc', description='Detailed description for the LLM')

@controller.action('My action', param_model=MyParams)
async def my_action(params: MyParams, browser_session: Browser) -> ActionResult:
    # Get the current CDP session to interact with the browser
    cdp_session = await browser_session.get_or_create_cdp_session()
    
    # Use CDP to type text
    await cdp_session.cdp_client.send.Input.insertText(
        params={'text': params.field2},
        session_id=cdp_session.session_id,
    )
    
    # Get current URL using CDP
    result = await cdp_session.cdp_client.send.Runtime.evaluate(
        params={'expression': 'window.location.href', 'returnByValue': True},
        session_id=cdp_session.session_id,
    )
    current_url = result.get('result', {}).get('value', 'unknown')
    
    return ActionResult(extracted_content=f"Inputted {params} on {current_url}")
```

Any special framework-provided arguments (e.g. `browser_session`) will be passed as separate positional arguments after `params`.

<Important>
To use a `BaseModel` the arg *must* be called `params`. Action function args are matched and filled like named arguments; arg order doesn't matter but names and types do.
</Important>

## Framework-Provided Parameters

These special action parameters are injected by the `Controller` and are passed as extra args to any actions that expect them.

For example, actions that need to interact with the browser should take the `browser_session` argument.

- `browser_session: Browser` - The current browser session with access to CDP for browser interaction
- `context: AgentContext` - Any optional top-level context object passed to the Agent, e.g. `Agent(context=user_provided_obj)`
- `page_extraction_llm: BaseChatModel` - LLM instance used for page content extraction
- `available_file_paths: list[str]` - List of available file paths for upload / processing
- `has_sensitive_data: bool` - Whether the action content contains sensitive data markers (check this to avoid logging sensitive data to terminal by accident)

<Note>
Browser Use has moved from Playwright to Chrome DevTools Protocol (CDP) for browser interaction. The `browser_session` provides access to CDP through `browser_session.agent_focus.cdp_client` or `await browser_session.get_or_create_cdp_session()`. Playwright is only used internally to install the browser binary, but all browser interaction is done via CDP.
</Note>

## Understanding the Browser Session Context

The `Browser` object provides multiple ways to interact with the browser:

### 1. Direct CDP Access
```python
# Get the current CDP session
cdp_session = await browser_session.get_or_create_cdp_session()

# Execute JavaScript
result = await cdp_session.cdp_client.send.Runtime.evaluate(
    params={'expression': 'document.title', 'returnByValue': True},
    session_id=cdp_session.session_id,
)

# Click at coordinates
await cdp_session.cdp_client.send.Input.dispatchMouseEvent(
    params={
        'type': 'mousePressed',
        'x': 100,
        'y': 200,
        'button': 'left',
        'clickCount': 1,
    },
    session_id=cdp_session.session_id,
)
await cdp_session.cdp_client.send.Input.dispatchMouseEvent(
    params={
        'type': 'mouseReleased',
        'x': 100,
        'y': 200,
        'button': 'left',
    },
    session_id=cdp_session.session_id,
)
```

### 2. Event-Based Actions
```python
from browser_use.browser.events import ClickElementEvent, TypeTextEvent, NavigateToUrlEvent

# Get a DOM element first
element = await browser_session.get_dom_element_by_index(5)

# Dispatch events through the event bus
click_event = browser_session.event_bus.dispatch(ClickElementEvent(node=element))
await click_event

type_event = browser_session.event_bus.dispatch(TypeTextEvent(node=element, text="Hello"))
await type_event

navigate_event = browser_session.event_bus.dispatch(NavigateToUrlEvent(url="https://example.com"))
await navigate_event
```

### 3. High-Level Browser Session Methods
```python
# Get current page information
state = await browser_session.get_browser_state_summary()
print(f"Current URL: {state.url}")
print(f"Page title: {state.title}")

# Take a screenshot
screenshot_path = await browser_session.take_screenshot()

# Get page HTML
html = await browser_session.get_page_html()

# Get all open tabs
tabs = await browser_session.get_tabs()
```

## Browser Session Examples

### Example: Basic Browser Interaction

```python
from browser_use import Browser, Controller, ActionResult

controller = Controller()

@controller.action('Type keyboard input into a page')
async def input_text_into_page(text: str, browser_session: Browser) -> ActionResult:
    # Get the current CDP session to interact with the browser
    cdp_session = await browser_session.get_or_create_cdp_session()
    
    # Use CDP to type text
    await cdp_session.cdp_client.send.Input.insertText(
        params={'text': text},
        session_id=cdp_session.session_id,
    )
    return ActionResult(extracted_content='Text input completed')
```

### Example: Tab Management

```python
from browser_use import Browser, Controller, ActionResult
from browser_use.browser.events import NavigateToUrlEvent, SwitchTabEvent

controller = Controller()

@controller.action('Open website')
async def open_website(url: str, browser_session: Browser) -> ActionResult:
    # Get all open tabs
    tabs = await browser_session.get_tabs()
    
    # Check if URL is already open in any tab
    for tab in tabs:
        if tab.url == url:
            # Switch to existing tab using events
            switch_event = browser_session.event_bus.dispatch(SwitchTabEvent(target_id=tab.target_id))
            await switch_event
            return ActionResult(extracted_content=f'Switched to existing tab with url {url}')
    
    # Otherwise, open URL in a new tab using events
    navigate_event = browser_session.event_bus.dispatch(NavigateToUrlEvent(url=url, new_tab=True))
    await navigate_event
    return ActionResult(extracted_content=f'Opened new tab with url {url}')
```

## Parameter Validation Rules

1. **Type hints on arguments are required**: They are used to verify that action params don't conflict with special arguments injected by the controller (e.g. `browser_session`)

2. **Actions functions called directly must be passed kwargs**: When calling actions from other actions or python code, you must **pass all parameters as kwargs only**, even though the actions are usually defined using positional args (for the same reasons as [pluggy](https://pluggy.readthedocs.io/en/stable/index.html#calling-hooks)).
   Action arguments are always matched by name and type, **not** positional order, so this helps prevent ambiguity / reordering issues while keeping action signatures short.
   ```python
   @controller.action('Fill in the country form field')
   async def input_country_field(country: str, browser_session: Browser) -> ActionResult:
       await some_action(123, browser_session=browser_session)                                # ❌ not allowed: positional args, use kwarg syntax when calling
       await some_action(abc=123, browser_session=browser_session)                            # ✅ allowed: action params & special kwargs
       await some_other_action(params=OtherAction(abc=123), browser_session=browser_session)  # ✅ allowed: params=model & special kwargs
   ```

## Parameter Pattern Examples

### Using Pydantic Model (Recommended)
```python
class PinCodeParams(BaseModel):
    code: int
    retries: int = 3                                               # ✅ supports optional/defaults

@controller.action('...', param_model=PinCodeParams)
async def input_pin_code(params: PinCodeParams, browser_session: Browser): ...   # ✅ special params at the end
```

### Using Function Arguments
```python
async def input_pin_code(code: int, retries: int, browser_session: Browser): ... # ✅ params first, special params second, no defaults
async def input_pin_code(code: int, retries: int=3): ...           # ✅ defaults ok only if no special params needed
async def input_pin_code(code: int, retries: int=3, browser_session: Browser): ... # ❌ Python SyntaxError! not allowed
```

## Advanced Parameter Patterns

### Complex Validation with Pydantic

```python
from typing import Annotated, Literal
from pydantic import BaseModel, Field, validator

class SearchParams(BaseModel):
    query: str = Field(min_length=1, description="Search query (required)")
    category: Literal["electronics", "books", "clothing"] = Field(default="electronics")
    price_range: tuple[float, float] = Field(default=(0.0, 1000.0))
    
    @validator('price_range')
    def validate_price_range(cls, v):
        if v[0] > v[1]:
            raise ValueError('Min price must be less than max price')
        return v

@controller.action('Search products with advanced filters', param_model=SearchParams)
async def search_products(params: SearchParams, browser_session: Browser) -> ActionResult:
    # LLM will receive full schema including validation rules
    ...
```

### Context-Aware Actions

```python
@controller.action('Process user data based on context')
async def process_user_data(
    user_id: str,
    context: AgentContext,  # Access to agent context
    browser_session: Browser
) -> ActionResult:
    # Use context data passed to Agent
    if hasattr(context, 'user_permissions'):
        if 'admin' not in context.user_permissions:
            return ActionResult(extracted_content="Access denied")
    
    # Process with permissions
    ...
```

## Next Steps

- Check out [real examples](https://github.com/browser-use/browser-use/tree/main/examples/custom-functions)
- Learn about [action registration patterns](/customize/tools-register)
- Read the [tools overview](/customize/tools-basic)